generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
}

enum Role {
  ADMIN
  INNENDIENST
  HANDWERKER
}

enum SchrittStatus {
  offen
  in_arbeit
  fertig
}

enum UpdateTyp {
  STATUS_AENDERUNG
  FOTO_UPLOAD
  NOTIZ
  MATERIAL_ANFORDERUNG
}

enum ApprovalStatus {
  ausstehend
  genehmigt
  abgelehnt
}

model User {
  id                  String               @id @default(uuid())
  email               String               @unique
  passwordHash        String
  vorname             String
  nachname            String
  erstelltAm          DateTime             @default(now())
  role                Role                 @default(HANDWERKER)
  projekte            Projekt[]
  sessions            Session[]
  passwordResetTokens PasswordResetToken[]

  // Handwerker updates submitted by this user
  eingereichteUpdates HandwerkerUpdate[] @relation("SubmittedUpdates")
  // Updates reviewed by this user (Innendienst/Admin)
  bearbeiteteUpdates  HandwerkerUpdate[] @relation("ReviewedUpdates")

  // Notes created by this user
  notizen Notiz[]

  // Audit log entries
  auditLogs AuditLog[]
}

model Session {
  id        String   @id
  expiresAt DateTime

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  projektId String?
  projekt   Projekt? @relation(fields: [projektId], references: [id], onDelete: Cascade)
}

model Projekt {
  id                  String  @id @default(uuid())
  auftragsnummer      String  @unique
  kundenname          String
  projektbezeichnung  String
  projektbeschreibung String? @db.Text
  mitarbeiter         User[]

  geplanterStart DateTime
  geplantesEnde  DateTime

  erstelltAm     DateTime @default(now())
  aktualisiertAm DateTime @updatedAt

  adresse  Adresse?
  schritte Schritt[]
  sessions Session[]
}

model Adresse {
  id         String @id @default(uuid())
  strasse    String
  hausnummer String
  plz        String
  ort        String

  projektId String  @unique
  projekt   Projekt @relation(fields: [projektId], references: [id], onDelete: Cascade)
}

model Schritt {
  id           String        @id @default(uuid())
  titel        String
  beschreibung String?
  startDatum   DateTime
  endDatum     DateTime
  status       SchrittStatus @default(offen)
  fortschritt  Int           @default(0)
  reihenfolge  Int

  projektId String
  projekt   Projekt @relation(fields: [projektId], references: [id], onDelete: Cascade)

  materialien MaterialBedarf[]
  bilder      Bild[]
  notizen     Notiz[]

  // Pending updates for this step
  pendingUpdates HandwerkerUpdate[]
}

model Bild {
  id String @id @default(uuid())

  daten          Bytes
  mimeType       String
  beschreibung   String?
  hochgeladenAm  DateTime @default(now())
  hochgeladenVon String

  schrittId String
  schritt   Schritt @relation(fields: [schrittId], references: [id], onDelete: Cascade)

  // Approval status - photos from Handwerker need approval before customer can see
  freigegeben Boolean @default(true)

  // Reference to the update if this was uploaded by Handwerker
  handwerkerUpdate HandwerkerUpdate?
}

model Material {
  id      String @id @default(uuid())
  name    String
  einheit String
  bestand Float  @default(0)

  verwendungen      MaterialBedarf[]
  handwerkerUpdates HandwerkerUpdate[]
}

model MaterialBedarf {
  id        String  @id @default(uuid())
  menge     Float
  bemerkung String?

  schrittId String
  schritt   Schritt @relation(fields: [schrittId], references: [id], onDelete: Cascade)

  materialId String
  material   Material @relation(fields: [materialId], references: [id])

  @@unique([schrittId, materialId])
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  email     String
  expiresAt DateTime
  createdAt DateTime @default(now())
  used      Boolean  @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Pending updates from Handwerker that need Innendienst approval
model HandwerkerUpdate {
  id  String    @id @default(uuid())
  typ UpdateTyp

  // Reference to the step being updated
  schrittId String
  schritt   Schritt @relation(fields: [schrittId], references: [id], onDelete: Cascade)

  // For status/progress updates - store the proposed new values
  neuerStatus      SchrittStatus?
  neuerFortschritt Int?

  // For notes
  notizText String? @db.Text

  // For photo uploads - reference to the uploaded image
  bildId String? @unique
  bild   Bild?   @relation(fields: [bildId], references: [id], onDelete: Cascade)

  // MATERIAL ANTRÃ„GE ---
  menge      Float? // Die angeforderte Menge
  materialId String?
  material   Material? @relation(fields: [materialId], references: [id])

  // Who submitted this update
  eingereichtVon String
  bearbeiter     User     @relation("SubmittedUpdates", fields: [eingereichtVon], references: [id])
  eingereichtAm  DateTime @default(now())

  // Approval workflow
  status          ApprovalStatus @default(ausstehend)
  bearbeitetVon   String?
  reviewer        User?          @relation("ReviewedUpdates", fields: [bearbeitetVon], references: [id])
  bearbeitetAm    DateTime?
  ablehnungsgrund String?        @db.Text
}

// Notes/remarks on project steps
model Notiz {
  id             String   @id @default(uuid())
  text           String   @db.Text
  erstelltAm     DateTime @default(now())
  aktualisiertAm DateTime @updatedAt

  // Author
  erstelltVon String
  autor       User   @relation(fields: [erstelltVon], references: [id])

  // Which step this note belongs to
  schrittId String
  schritt   Schritt @relation(fields: [schrittId], references: [id], onDelete: Cascade)

  // Visibility control - notes are internal by default
  // Only becomes visible to customer after Innendienst approval
  sichtbarFuerKunde Boolean @default(false)
}

// Immutable audit log for all changes
model AuditLog {
  id String @id @default(uuid())

  aktion String

  details String @db.Text

  zeitpunkt DateTime @default(now())

  userId   String
  benutzer User   @relation(fields: [userId], references: [id])

  projektId String?
  schrittId String?

  // This table should never be updated or deleted - audit entries are immutable
  @@index([projektId])
  @@index([userId])
  @@index([zeitpunkt])
}
